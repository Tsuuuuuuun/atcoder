# memo

## A

### 問題文

以下の条件を満たす正整数 $x$を **321-like Number** と呼びます。

- $x$の各桁を上から見ると狭義単調減少になっている。
- すなわち、 $x$ が $d$桁の整数だとすると、 $1 \le i < d$を満たす全ての整数 $i$について以下の条件を満たす。
  - ( $x$の上から $i$桁目 ) > ( $x$の上から $i+1$桁目 )

なお、 $1$桁の正整数は必ず 321-like Number であることに注意してください。

例えば、 $321,96410,1$は 321-like Number ですが、 $123,2109,86411$は 321-like Number ではありません。

$N$が入力として与えられるので、 $N$が 321-like Number なら `Yes` 、そうでないなら `No` と出力してください。

#### 制約

- 入力は全て整数
- $1 \le N \le 99999$

### memo

- $N$ を文字列として受け取ることで桁ごとの大小比較が可能になる.

## B

### 問題文

以下の手順で行われる試験があります。

- 試験は $1$ ラウンド目から $N$ ラウンド目までの $N$ ラウンドからなります。
- 各ラウンドに対し、 $0$ 以上 $100$ 以下の整数でスコアが与えられます。
- $N$ ラウンドのスコアのうち、最高スコアと最低スコアを除いた $N-2$ ラウンドのスコアの合計が最終結果となります。
  - 厳密には、各ラウンドのスコアを昇順に並べた列を $S=(S_1,S_2,\dots,S_N)$ としたとき、最終結果は $S_2+S_3+\dots+S_{N-1}$ となります。

現在、試験のうち $N-1$ ラウンドが終了し、 $i$ ラウンド目のスコアは $A_i$ でした。
最終結果を $X$ 以上とするために $N$ ラウンド目に取るべきスコアの最小値を出力してください。
但し、 $N$ ラウンド目に取りうるスコアは $0$ 以上 $100$ 以下の整数であることに注意してください。

#### 制約

- 入力は全て整数
- $3 ≤ N ≤ 100$
- $0 ≤ X ≤ 100 * (N-2)$
- $0 ≤ A_i ≤ 100$

### memo

- $N-1$ラウンドの結果までは既に出ている.
- $N$ラウンド目の得点に関しては, $0$ 以上 $100$ 以下の整数であることがわかっているので, それを全探索して解を探しに行く.
- リストに要素を追加するとき, `append()`はよく使うがこれはリストを変形させてしまう. 元のリストを保持した状態で要素を追加したいときは`+`演算子を使う.

例:

```Python
scores = A + [i]
```

## C

### 問題文

以下の条件を満たす正整数 $x$ を **321-like Number** と呼びます。 **この定義は A 問題と同様です。**

- $x$ の各桁を上から見ると狭義単調減少になっている。
- すなわち、 $x$ が $d$ 桁の整数だとすると、 $1 \le i < d$ を満たす全ての整数 $i$ について以下の条件を満たす。
  - ( $x$ の上から $i$ 桁目 ) > ( $x$ の上から $i+1$ 桁目 )

なお、 $1$ 桁の正整数は必ず 321-like Number であることに注意してください。

例えば、 $321, 96410, 1$ は 321-like Number ですが、 $123, 2109, 86411$ は 321-like Number ではありません。

$K$ 番目に小さい 321-like Number を求めてください。

#### 制約

- 入力は全て整数
- $1 \le K$
- 321-like Number は $K$ 個以上存在する

### memo

- 最大の $321$-like Number は $9876543210$ であることがわかっている. $K$ の最大値は $2^{10}-2=1022$ である.
- A問題と同様に文字列として受け取ることで桁ごとの大小比較が可能になる.
- 書いたコードの計算量は`while` で $K$ 回ループを回し, `while` 内の `for` 文で $10$ 回のループと, $\log_{10}n$ 回のループがあるので, 結果として $O(K\log K)$ となる. これは十分高速である.

## D

### 問題文

AtCoder 食堂では $N$ 種類の主菜と $M$ 種類の副菜が提供されており、 $i$ 種類目の主菜の価格は $A_i$、 $j$ 種類目の副菜の価格は $B_j$ です。
AtCoder 食堂では新たに定食のメニューを設けることを検討しています。
定食は $1$ 種類の主菜と $1$ 種類の副菜から構成され、主菜と副菜の価格の和を $s$ としたとき、定食の価格は $\min(s,P)$ です。
ここで、 $P$ は入力で与えられる定数です。

定食を構成する主菜と副菜の選び方は $NM$ 通りありますが、それらすべてに対する定食の価格の総和を求めてください。

## 制約

- $1\leq N,M \leq 2\times 10^5$
- $1\leq A_i,B_j \leq 10^8$
- $1\leq P \leq 2\times 10^8$
- 入力は全て整数

### memo

- 普通に足し合わせていては計算量が $O(NM)$ となり, $N,M$ の制約から間に合わない.
- 求めたいものは $\sum_{i=1}^N \sum_{j=1}^M \min(A_i+B_j,P)$ である.
- 各 $i(1\le i \le N)$ について, $i$ 種類目の主催を用いた定食の価格の総和, すなわち $\sum_{j=1}^M \min(A_i+B_j,P)$ を考える.
- $B_j < P - A_i$ を満たす最大の $j$ を $k_i$ とする. このとき, 求める値は以下のように表せる.

$$
\sum_{j-i}^M \min(A_i+B_j,P) = \sum_{j=1}^{k_i} (A_i+B_j) + \sum_{j=k_i+1}^M P = A_i k_i + \sum_{j=1}^M B_j + P(M-k_i)
$$

- $k_i$ の値は二分探索を用いて, $\sum_{j=1}^{k_i}B_j$ は累積和を用いることで高速化が可能となる.
- 結果, 計算量は $O((N+M)\log N)$ となり, $N,M$ の制約から間に合う.
