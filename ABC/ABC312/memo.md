
# A

与えられた文字列がACE、BDF、CEG、DFA、EGB、FAC、GBDと等しいかどうかを判別.

# B

グリッドの問題. ゴリ押しの方法しか知らない. 結局気にするのは左上と右下なのでそこがあっているかどうかを判定すればOK.

# C

愚直に求めると計算量が大きくなってしまう. 二分探索の出番. leftとrightの取り方に気をつけましょう(自戒).

# D

dpで解く. 文字列の長さを`n` とする. `dp[i][j]` を、最初の `i` 文字を考慮したとき, `(` の数と `)`の数の差が `j` であるような置き換えの方法の数とする.

dpを更新するための遷移を考える.

- `S[i]` が `(` の場合： `dp[i+1][j+1] += dp[i][j]`
- `S[i]` が `)` の場合： `dp[i+1][j-1] += dp[i][j]` (`j > 0`の場合のみ)
- `S[i]` が `?` の場合：`(` と `)` のどちらとしても解釈できるため, 以下の2つの遷移を行う：
  - `dp[i+1][j+1] += dp[i][j]`
  - `dp[i+1][j-1] += dp[i][j]` ( `j>0` の場合のみ)

すべての文字を処理した後、`dp[n][0]` が最終的な答えとなる.
